---
slug: topology-sort
title: 拓扑排序
date: 2024-09-02
authors: Fanceir
tags: [algorithm]
keywords: [algorithm, topology-sort]
image: https://s2.loli.net/2024/07/24/AtKjn1zUePX6uVp.png
---


今天写个拓扑排序，这是图论的内容，之前在学的时候没学好，第一次培训这个拓扑排序也没做出来。
啥是拓扑排序呢？

>拓扑排序是对有向无环图的顶点的一种排序，它使得如果存在一条从顶点 $u$ 到顶点 $v$ 的路径，那么在排序中 $u$ 出现在 $v$ 的前面。例如，一个拓扑排序为 $v_1,v_2,v_3,v_4,v_5$，那么对于任何 $v_i$ 到 $v_j$ 的边，$v_i$ 都出现在 $v_j$ 的前面。拓扑排序的结果不是唯一的。拓扑排序可以用来判断一个有向图是否是无环图。有向无环图（DAG）才有拓扑排序。

>就像是你烧菜需要先把菜洗了，然后切了，然后炒了，最后才能吃，这就是一个拓扑排序，你不能先吃了再切菜，这样就不对了，这就是一个有向无环图，有向是因为你不能反过来，无环是因为你不能循环，你不能先吃了再切菜，然后再吃了，然后再切菜，这样就循环了，所以这是一个有向无环图，这就是拓扑排序。

先来一道例题吧

You are given 5 different sizes of kitchen plates. Each plate is marked with a letter $A$, $B$, $C$, $D$, or $E$. You are given 5 statements comparing two different plates, you need to rearrange the plates from smallest size to biggest size. For example: the sizes of these plates.
![](https://espresso.codeforces.com/39269782371c984cd42f2d62db51ae91b9ceb12d.png)
**Input**

The input consist of 5 lines. In each line there will be 3 characters, the first and last character will be either $A$, $B$, $C$, $D$, or $E$ and the middle character will be either $<$ or $>$ describing the comparison between two plates sizes. No two plates will be equal.

**Output**

The output consist of $5$ characters, the sorted order of balls from smallest to biggest plate. Otherwise, if the statements are contradicting print $impossible$. If there are multiple answers, print any of them.

```cpp
#include <bits/stdc++.h>
using namespace std;
int degree[5];
vector<int> ans;
void toposort(vector<int> G[], int degree[]) // G是邻接表，degree是入度数组
{
    queue<int> q; // 存放入度为0的点
    for (int i = 0; i < 5; i++)
    {
        if (degree[i] == 0)
        {
            q.push(i); // 入度为0的点入队
        }
    }
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        ans.push_back(u);
        for (int i = 0; i < G[u].size(); i++)
        {
            int v = G[u][i];
            degree[v]--;
            if (degree[v] == 0)
            {
                q.push(v);
            }
        }
    }
}
int main()
{
    int t = 5;
    vector<int> G[t];
    while (t--)
    {
        string s;
        cin >> s;
        int a = s[0] - 'A';
        int b = s[2] - 'A';
        char op = s[1];
        if (op == '<')
        {
            G[a].push_back(b);
            degree[b]++;
        }
        else
        {
            G[b].push_back(a);
            degree[a]++;
        }
    }
    toposort(G, degree);
    if (ans.size() < 5)
    {
        cout << "impossible" << endl;
    }
    else
    {
        for (int i = 0; i < ans.size(); i++)
        {
            cout << char(ans[i] + 'A');
        }
        cout << endl;
    }
    return 0;
}
```

有N个比赛队，编号依次为1，2，3，。。。。，N进行比赛，比赛结束后，裁判委员会要将所有参赛队伍从前往后依次排名，但现在裁判委员会不能直接获得每个队的比赛成绩，只知道每场比赛的结果，即P1赢P2，用P1，P2表示，排名时P1在P2之前。现在请你编程序确定排名。

**Input**

输入有若干组，每组中的第一行为二个数N（1<=N<=500），M；其中N表示队伍的个数，M表示接着有M行的输入数据。接下来的M行数据中，每行也有两个整数P1，P2表示即P1队赢了P2队。

**Output**

给出一个符合要求的排名。输出时队伍号之间有空格，最后一名后面没有空格。

其他说明：符合条件的排名可能不是唯一的，此时要求输出时编号小的队伍在前；输入数据保证是正确的，即输入数据确保一定能有一个符合要求的排名。
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m;
void toposort(vector<int> G[], vector<int> degree)
{
    queue<int> ans; // 答案队列
    priority_queue<int, vector<int>, greater<int>> q;
    for (int i = 0; i < n; i++)
    {
        if (degree[i] == 0)
        {
            q.push(i);
        }
    }
    while (!q.empty())
    {
        int u = q.top();
        q.pop();
        ans.push(u);
        for (int i = 0; i < G[u].size(); i++)
        {
            int v = G[u][i];
            degree[v]--;
            if (degree[v] == 0)
            {
                q.push(v);
            }
        }
    }
    while (!ans.empty())
    {
        cout << ans.front() + 1 << " "; // 之前把编号减了一，这里要加回来
        ans.pop();
    }
    cout << endl;
}
int main()
{
    while (~scanf("%d%d", &n, &m))
    {
        vector<int> G[n];
        vector<int> degree(n);
        for (int i = 1; i <= m; i++)
        {
            int x, y;
            cin >> x >> y;
            G[x - 1].push_back(y - 1); // 因为这里是从1开始的，所以要减一
            degree[y - 1]++;           // 入度加一
        }
        toposort(G, degree);
    }
    return 0;
}
```